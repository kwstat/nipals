[{"path":"https://kwstat.github.io/nipals/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 nipals authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kwstat.github.io/nipals/articles/empca_notes.html","id":"complete-data-example","dir":"Articles","previous_headings":"","what":"Complete data example","title":"EMPCA notes","text":"","code":"# Python: Coeff (scores) [[-2.809  0.097  0.244  0.050]  [-1.834  0.286  0.010 -0.135]  [-0.809  0.963 -0.341  0.078]  [-0.155 -1.129  0.548  0.026]  [0.707  -0.723 -0.736 -0.024]  [1.830  -0.290 -0.157  0.030]  [3.070   0.796  0.431 -0.026]]  # m1e <- empca(x=B1, w=B1wt, ncomp=4) # Un-sweep the eigenvalues to compare to python results # R round( sweep( m1e$scores, 2, m1e$eig, \"*\"), 3)       PC1    PC2    PC3    PC4 G1 -2.809  0.097 -0.244  0.050 G2 -1.834  0.286 -0.010 -0.135 G3 -0.809  0.963  0.341  0.078 G4 -0.155 -1.129 -0.548  0.026 G5  0.707 -0.723  0.736 -0.024 G6  1.830 -0.290  0.157  0.030 G7  3.070  0.796 -0.431 -0.026  # Matlab: P (scores)   0.5590   0.0517   0.2210   0.2910   0.3650   0.1520   0.0095  -0.7840   0.1610   0.5120  -0.3080   0.4530   0.0309  -0.6010   0.4950   0.1510  -0.1410  -0.3850  -0.6640  -0.1380  -0.3650  -0.1540  -0.1420   0.1760  -0.6110   0.4230   0.3890  -0.1490  # R: round(m1e$scores, 3)       PC1    PC2    PC3    PC4 G1 -0.559 -0.052  0.221 -0.291 G2 -0.365 -0.152  0.009  0.784 G3 -0.161 -0.512 -0.308 -0.453 G4 -0.031  0.601  0.495 -0.151 G5  0.141  0.385 -0.664  0.138 G6  0.365  0.154 -0.142 -0.176 G7  0.611 -0.423  0.389  0.149"},{"path":"https://kwstat.github.io/nipals/articles/empca_notes.html","id":"missing-data-example","dir":"Articles","previous_headings":"","what":"Missing data example","title":"EMPCA notes","text":"","code":"# Python with initial Identity matrix  [[2.791 0.125 0.325 -0.035]  [1.528 -0.989 -0.211 0.172]  [0.990 -0.651 -0.117 -0.186]  [0.159 1.463 0.530 0.020]  [-0.628 0.862 -0.730 -0.032]  [-1.738 0.406 -0.139 -0.071]  [-2.917 -0.712 0.520 -0.047]]   Eigvec (loadings) [[-0.309 -0.839 -0.298 0.300]  [-0.502 0.014 0.154 -0.615]  [-0.470 -0.086 0.766 0.219]  [-0.441 0.521 -0.236 0.615]  [-0.487 0.128 -0.496 -0.326]]    # R   R> m2e <- empca(x=B2, w=B2wt, ncomp=4, seed=NULL) # # Un-sweep the eigenvalues to compare to python results R> round( sweep( m2e$scores, 2, m2e$eig, \"*\"), 3)       PC1    PC2    PC3    PC4 G1 -2.791  0.216 -0.356  0.066 G2 -1.528 -0.942  0.187 -0.150 G3 -0.990 -0.620  0.101  0.207 G4 -0.159  1.472 -0.522 -0.032 G5  0.628  0.844  0.744  0.021 G6  1.738  0.351  0.161  0.050 G7  2.917 -0.808 -0.493  0.019 R> round( m2e$loadings, 3)      PC1    PC2    PC3    PC4 E1 0.309 -0.839  0.298 -0.300 E2 0.502  0.014 -0.154  0.615 E3 0.470 -0.086 -0.766 -0.219 E4 0.441  0.521  0.236 -0.615 E5 0.487  0.128  0.496  0.326"},{"path":"https://kwstat.github.io/nipals/articles/empca_notes.html","id":"python","dir":"Articles","previous_headings":"","what":"Python","title":"EMPCA notes","text":"Python code Bailey (2012), retrieved 1 Mar 2019 https://github.com/sbailey/empca . Python code difficult read places person [like ] well-versed Python. Three examples: clear values k takes k range(self.nvec). Gram-Schmidt orthogonalization accomplished pair nested loops instead function. Model class structure makes bit tricky figure objects actually modified inside function. Python code iterates two EM steps: Calculate coefficient matrix C. Calculate ncomp principal components P simultaneously (iterate convergence). Orthogonalize P. complete-data problem, python R give similar results. Note Coeff matrix python eigenvalues swept columns. missing-data problem, python results somewhat different R.","code":""},{"path":"https://kwstat.github.io/nipals/articles/empca_notes.html","id":"matlab","dir":"Articles","previous_headings":"","what":"Matlab","title":"EMPCA notes","text":"Matlab code Vicente Parot, retrieved 1 Mar 2019 https://www.mathworks.com/matlabcentral/fileexchange/45353-empca. Matlab code feels similar R. Matlab code calculates principal components sequentially, one time. principal component, algorithm iterates two steps: Calculate C[,h] Calculate P[,h] type EM algorithm, algorithm described Bailey (2012) considered .","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_algorithm.html","id":"singular-value-decomposition","dir":"Articles","previous_headings":"","what":"Singular value decomposition","title":"The NIPALS algorithm","text":"SVD (Singular Value Decomposition) matrix XX $$ \\bf X = U S V', $$ $\\bf U$ (n×r)(n \\times r) $\\bf V$ (k×r)(k \\times r) orthogonal matrices $\\bf S$ diagonal matrix rr singular values. SVD allow missing values data.","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_algorithm.html","id":"nipals","dir":"Articles","previous_headings":"","what":"NIPALS","title":"The NIPALS algorithm","text":"NIPALS (Nonlinear Iterative Partial Least Squares) algorithm can used find first () principal components decomposition $$ \\bf X = \\bf T \\bf P ' $$ columns $\\bf T$ called scores columns $\\bf P$ (rows $\\bf P'$) called loadings. algorithm begins initializing h=1h=1 $\\bf X_h = \\bf X$, proceeds following basic steps: Choose $\\bf t_h$ column $\\bf X_h$. Compute loadings $\\bf p_h = X_h' t_h / t_h' t_h$. Let $\\bf p_h = p_h / \\sqrt{p_h' p_h}$. Compute scores $\\bf t_h = X_h p_h / p_h' p_h$. Repeat (3) (4) convergence hthh^{th} principal component. Let $\\bf X_{h+1} = \\bf X_h - t_h p_h'$. Let $\\lambda_h = \\bf t_h' t$ (eigen value). Increment h=h+1h = h + 1 repeat next principal component. Assemble columns $\\bf T$ $\\bf t_h$ columns $\\bf P$ vectors $\\bf p_h$. resulting PCs may scaled different ways. One way scale PCA solution define loadings $\\bf P = V$ $\\bf T = U'S$.","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_algorithm.html","id":"missing-data","dir":"Articles","previous_headings":"NIPALS","what":"Missing data","title":"The NIPALS algorithm","text":"NIPALS algorithm can modified accommodate missing values using method Martens Martens (2001) (p. 381). , certain variable kk [column $\\bf X$], missing value encountered $\\bf X$ certain object ii [row $\\bf X$], corresponding elements $\\bf t_{ih}$ must also skipped calculation loadings, $\\bf X$-variable kk $$ \\bf p_{hk} = X_{k,h-1} t_h'  / (t_h' t_h) . $$ Likewise, , certain sample ii [row $\\bf X$], missing value encountered $\\bf X$ certain variable kk [column $\\bf X$], corresponding elements $\\bf p_{kh}$ must also skipped calculating scores, sample ii $$ \\bf t_{ih} = X_{,h-1} p_h / (p_h' p_h) $$ method may convergence problems many missing values.","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_algorithm.html","id":"gram-schmidt-orthogonalization","dir":"Articles","previous_headings":"NIPALS","what":"Gram-Schmidt orthogonalization","title":"The NIPALS algorithm","text":"accumulation floating-point errors, orthogonality principal components quickly lost number components increases. Andrecut (2009) provided Gram-Schmidt modified version NIPALS stabilizes orthogonality re-orthogonalizing scores loadings iteration. ‘corrected’ terms : $$ \\bf p_c = p - P_{1:h} P_{1:h}' p $$ $$ \\bf t_c = t - T_{1:h} T_{1:h}' t $$ $\\bf P_{1:h}$ $\\bf T_{1:h}$ loadings scores matrices based first hh principal components. Since $\\bf P_{1:h} P_{1:h}'$ needs calculated PC (incrementally), orthogonalization computationally expensive. correction method also used SAS PROC HPPRINCOMP (allow missing values).","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_algorithm.html","id":"example-1","dir":"Articles","previous_headings":"NIPALS","what":"Example 1","title":"The NIPALS algorithm","text":"small dataset two missing values. Model m1 omits Gram-Schmidt orthogonalization step iteration. Model m2 includes . eigenvalues two models similar. theory, loadings matrix $\\bf P$ orthogonal $\\bf P' P = $. missing values, however, calculation approximate PCs causes numerical errors accumulate, practice first components can accurately calculated. (coordinates last PC can often quite poor.) small example, first 3 PCs model m1 fairly orthogonal, 4th 5th PC good. model m2, PCs nearly exactly orthogonal. Also theory, $\\bf T' T = $ (eigenvalues removed T), missing values invalidate identity, unless Gram-Schmidt method used.","code":"require(nipals) ## Loading required package: nipals B <- matrix(c(50, 67, 90, 98, 120,               55, 71, 93, 102, 129,               65, 76, 95, 105, 134,               50, 80, 102, 130, 138,               60, 82, 97, 135, 151,               65, 89, 106, 137, 153,               75, 95, 117, 133, 155), ncol=5, byrow=TRUE) B2 <- B B2[1,1] <- B2[2,1] <- NA m0 <- svd(scale(B)) # center and scale require(\"nipals\") m1 <- nipals::nipals(B2, gramschmidt=FALSE) m2 <- nipals::nipals(B2, gramschmidt=TRUE) round( m1$eig, 3) ## [1] 4.876 2.044 1.073 0.237 0.143 round( m2$eig, 3) ## [1] 4.876 2.035 1.079 0.234 0.133 # loadings round( crossprod(m1$loadings), 3) # P'P = t(P) %*% P ##        PC1    PC2    PC3    PC4    PC5 ## PC1  1.000  0.011  0.006 -0.043 -0.416 ## PC2  0.011  1.000 -0.011 -0.003  0.125 ## PC3  0.006 -0.011  1.000 -0.050 -0.058 ## PC4 -0.043 -0.003 -0.050  1.000 -0.006 ## PC5 -0.416  0.125 -0.058 -0.006  1.000 round( crossprod(m2$loadings), 3) ##     PC1 PC2 PC3 PC4 PC5 ## PC1   1   0   0   0   0 ## PC2   0   1   0   0   0 ## PC3   0   0   1   0   0 ## PC4   0   0   0   1   0 ## PC5   0   0   0   0   1 # scores round( crossprod(m1$scores), 3) # T'T = t(T) %*% T ##        PC1    PC2    PC3    PC4    PC5 ## PC1  1.000 -0.086  0.058 -0.287  0.218 ## PC2 -0.086  1.000  0.003 -0.014  0.003 ## PC3  0.058  0.003  1.000  0.013 -0.002 ## PC4 -0.287 -0.014  0.013  1.000  0.004 ## PC5  0.218  0.003 -0.002  0.004  1.000 round( crossprod(m2$scores), 3) ##     PC1 PC2 PC3 PC4 PC5 ## PC1   1   0   0   0   0 ## PC2   0   1   0   0   0 ## PC3   0   0   1   0   0 ## PC4   0   0   0   1   0 ## PC5   0   0   0   0   1"},{"path":[]},{"path":"https://kwstat.github.io/nipals/articles/nipals_comparisons.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example data","title":"Comparing results and performance of NIPALS functions in R","text":"small dataset 2 missing values first column used compare numerical results 4 packages. Since principal components unique change sign, small function () defined take absolute values calling .equal. () function used compare results different functions. next 3 sections, results nipals package compared ade4, plsdepot, mixOmics packages respectively.","code":"B <- matrix(c(50, 67, 90, 98, 120,              55, 71, 93, 102, 129,              65, 76, 95, 105, 134,              50, 80, 102, 130, 138,              60, 82, 97, 135, 151,              65, 89, 106, 137, 153,              75, 95, 117, 133, 155), ncol=5, byrow=TRUE) rownames(B) <- c(\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\",\"G7\") colnames(B) <- c(\"E1\",\"E2\",\"E3\",\"E4\",\"E5\")   B2 = B B2[1,1] = B2[2,1] = NA B2 <- as.matrix(B2)  same <- function(a,b, tol=1e-3){   all.equal( abs(a), abs(b), tol=tol, check.attributes=FALSE) }"},{"path":"https://kwstat.github.io/nipals/articles/nipals_comparisons.html","id":"ade4","dir":"Articles","previous_headings":"","what":"ade4","title":"Comparing results and performance of NIPALS functions in R","text":"ade4 package uses maximum-likelihood scaling data divides n instead n-1, need scale data hand using nipals package. Note: ade4 version >= 1.7-10. eigenvalues reported ade4 squared singular values divided n−1n-1.","code":"library(ade4) made <- ade4::nipals(B2, nf=5, rec=TRUE, niter=500, tol=1e-9)  B2a <- apply(B2, 2, function(x) {   n <- sum(!is.na(x))   x <- x - mean(x, na.rm=TRUE)   x <- x / ( sd(x, na.rm=TRUE) * sqrt((n-1) / n )) })  mnip <- nipals::nipals(B2a, ncomp=5, center=FALSE, scale=FALSE,                         fitted=TRUE, maxiter=500, tol=1e-9, gramschmidt=FALSE) # data same(B2a, as.matrix(made$tab)) # TRUE  # eigenvalues, ade4 uses squared singular values / n-1 mnip$eig # [1] 5.2913781 2.2555596 1.1651281 0.2590878 0.1563175 made$eig # [1] 4.666454778 0.847924398 0.226254436 0.011187921 0.004072542 same(mnip$eig ^ 2 / (nrow(B2a)-1), made$eig) # TRUE  # P loadings same(mnip$loadings, made$c1) # TRUE  # T scores. For nipals, sweep IN the eigenvalues same( sweep(mnip$scores, 2, mnip$eig, \"*\"), made$li) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_comparisons.html","id":"plsdepot","dir":"Articles","previous_headings":"","what":"plsdepot","title":"Comparing results and performance of NIPALS functions in R","text":"plsdepot package reports squared singular values.","code":"library(plsdepot) mpls <- plsdepot::nipals(B2, comps=5) library(nipals) mnip <- nipals::nipals(B2a, ncomp=5, maxiter=100, tol=1e-6, gramschmidt=FALSE) # eigenvalues mnip$eig # [1] 4.8762167 2.0442757 1.0728055 0.2369607 0.1432779 mpls$values[,1] # [1] 3.963172007 0.696484184 0.191839875 0.009366425 0.003421661 same(mnip$eig, sqrt(mpls$values[,1] * 6) ) # TRUE  # P loadings mnip$loadings mpls$loadings same(mnip$loadings, mpls$loadings, tol=1e-2 ) # TRUE  # T scores mnip$scores mpls$scores same( sweep(mnip$scores, 2, mnip$eig, \"*\"), mpls$scores) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_comparisons.html","id":"mixomics","dir":"Articles","previous_headings":"","what":"mixOmics","title":"Comparing results and performance of NIPALS functions in R","text":"","code":"library(mixOmics) library(nipals) mnip <- nipals::nipals(B2, gramschmidt=FALSE) mmix <- mixOmics::nipals(scale(B2), ncomp=5) # eigenvalues mnip$eig mmix$eig same(mnip$eig, mmix$eig) # TRUE  # P loadings mnip$loadings mmix$p same(mnip$loadings, mmix$p, tol=1e-2) # TRUE  # T scores mnip$scores mmix$t same(mnip$scores, mmix$t, tol=1e-2) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_comparisons.html","id":"speed-comparison","dir":"Articles","previous_headings":"","what":"Speed comparison","title":"Comparing results and performance of NIPALS functions in R","text":"purpose comparing performance functions, simulate 100 x 100 matrix insert one missing value. ade4::nipals function uses loops loop columns X, results slow execution even calculating 1 principal component. plsdepot::nipals function fast enough 100 PCs can calculated. mixOmics::nipals function uses crossprod function tricks improve performance. nipals::nipals function optimized extensive testing 5 times faster! Note Gram-Scmidt turned order make fair comparison functions. Gram-Schmidt turned (default setting), function bit slower. nipals::empca function results tentative:","code":"set.seed(43) Bbig <- matrix(rnorm(100*100), nrow=100) Bbig2 <- Bbig Bbig2[1,1] <- NA system.time(ade4::nipals(Bbig2, nf=1)) # Only 1 PC! ##  user  system elapsed  ## 42.09    0.00   42.14 system.time(plsdepot::nipals(Bbig2, comps=1)) # Only 1 PC ! #   user  system elapsed  #    0.5     0.0     0.5 system.time(plsdepot::nipals(Bbig2, comps=100)) # 100 PCs #   user  system elapsed  #  30.19    0.00   30.18 system.time(mixOmics::nipals(scale(Bbig2), ncomp=100)) # 100 PCs #   user  system elapsed  #  20.70    0.00   20.81 system.time(nipals::nipals(Bbig2, ncomp=100, gramschmidt=FALSE)) # 100 PCs #   user  system elapsed  #   2.93    0.00    2.93 system.time(nipals::nipals(Bbig2, ncomp=100, gramschmidt=TRUE)) # 100 PCs #   user  system elapsed  #    3.6     0.0     3.6 system.time(empca(Bbig2, ncomp=100, gramschmidt=FALSE)) # 100 PCs #   user  system elapsed  #   1.03    0.00    1.03  system.time(empca(Bbig2, ncomp=100, gramschmidt=TRUE)) # 100 PCs #   user  system elapsed  #  10.44    0.00   10.45"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"NIPALS optimization notes","text":"notes document optimization process nipals function. , complete R code chunks re-run. Optimizing performance skill requires good understanding functions manage memory calculations, also involves fair bit trial error. example, code optimal small data may optimal large data. can also trade-code optimal code readable. view leans heavily toward philosophy programmer time expensive processor time, code written humans.","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"general-computational-performance-tips","dir":"Articles","previous_headings":"","what":"General computational performance tips","title":"NIPALS optimization notes","text":"section x y matrices v vector. possible, avoid looping columns matrix. Instead, use apply similar functions. use cbind (rbind) assemble results matrix. Instead, initialize full matrix NA values insert results appropriate column matrix. Use x*x instead x^2. (true, R automatically). Use sqrt(x) instead x^0.5. Use crossprod(x,y) instead t(x) %*% y, since latter transpose first multiply. Use crossprod(v) instead sum(v*v) v lot million numbers result numeric overflow. Use colSums(x*x) instead diag(crossprod(x)) x much wider 1000 columns. Avoid making copies data structures, avoid repeating calculations.","code":"v = rnorm(1e8) # 100 million system.time(crossprod(v)) #   user  system elapsed  #   0.24    0.00    0.23  system.time(sum(v*v)) #   user  system elapsed  #   0.24    0.17    0.40   v = rnorm(1e9) # 1000 million system.time(crossprod(v)) #   user  system elapsed  #   2.99    0.72   19.20  system.time(sum(v*v)) #   user  system elapsed  #   3.25   45.71  141.76   v = 1:1e6 # 1 million system.time(crossprod(v)) #   user  system elapsed  #      0       0       0  system.time(sum(v*v)) #   user  system elapsed  #      0       0       0  # Warning message: # In k * k : NAs produced by integer overflow x = matrix(rnorm(10000), nrow=10, ncol=1000) system.time(colSums(x*x)) #   user  system elapsed  #      0       0       0  system.time(crossprod(x)) #   user  system elapsed  #   0.83    0.14    0.97"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"calculating-scores-t-xppp","dir":"Articles","previous_headings":"","what":"Calculating scores t = Xp/p’p","title":"NIPALS optimization notes","text":"Part NIPALS algorithm involves iterating calculating loadings $\\bf p$ scores $\\bf t$. section shows ideas tried increase performance calculation $\\bf t$ vector. testing purposes, 100×100100 \\times 100 matrix big enough tweaks code show differences performance time, small enough call function require lot waiting. missing value inserted force function use method needed missing data. optimizing process, use code taken mixOmics::nipals since avoids loops columns $\\bf X$, better performance ade4::nipals plsdepot::nipals. timings median 3 runs. timings section recorded Gram-Schmidt orthogonalization step added.","code":"set.seed(42) Bbig <- matrix(rnorm(100*100), nrow=100) Bbig2 <- Bbig Bbig2[1,1] <- NA"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"version-1","dir":"Articles","previous_headings":"Calculating scores t = Xp/p’p","what":"Version 1","title":"NIPALS optimization notes","text":"version taken mixOmics package.","code":"th = x0 %*% ph P = drop(ph) %o% nr.ones # ph in each column, nr.ones is a vector of 1 P[t(x.miss)] = 0 ph.cross = crossprod(P) th = th / diag(ph.cross)  system.time(res0 <- nipals(Bbig2, ncomp=100)) #   user  system elapsed  #  10.76    0.00   10.78"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"version-2","dir":"Articles","previous_headings":"Calculating scores t = Xp/p’p","what":"Version 2","title":"NIPALS optimization notes","text":"’s need store ph.cross object, diag(crossprod()) needlessly expensive since need diagonal elements. easy change big reward.","code":"th = x0 %*% ph P = drop(ph) %o% nr.ones # ph in each column P[t(x.miss)] = 0 th = th / colSums(P*P)  system.time(res <- nipals(Bbig2, ncomp=100)) #   user  system elapsed  #    4.4     0.0     4.4  all.equal(res0, res) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"version-3","dir":"Articles","previous_headings":"Calculating scores t = Xp/p’p","what":"Version 3","title":"NIPALS optimization notes","text":"columns P , element-wise multiplication P*P repeating lot multiplications different columns. Better square numbers one column, put columns. Also, ’s need calculate th two steps.","code":"P2 <- drop(ph*ph) %o% nr.ones # ph in each column P2[t(x.miss)] <- 0 th = x0 %*% ph / colSums(P2)  system.time(res <- nipals(Bbig2, ncomp=100)) #   user  system elapsed  #      4       0       4   all.equal(res0, res) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"version-4","dir":"Articles","previous_headings":"Calculating scores t = Xp/p’p","what":"Version 4","title":"NIPALS optimization notes","text":"first line code squaring elements ph, outer-multiplying vector 1s insert column P2. makes sense algebraically, can avoid multiplications just build matrix P2 recycling first column.","code":"P2 <- matrix(ph*ph, nrow=nc, ncol=nr) P2[t(x.miss)] <- 0 th = x0 %*% ph / colSums(P2)  system.time(res <- nipals(Bbig2, ncomp=100)) #   user  system elapsed  #   3.38    0.00    3.41      all.equal(res0, res) # TRUE"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"comments","dir":"Articles","previous_headings":"Calculating scores t = Xp/p’p","what":"Comments","title":"NIPALS optimization notes","text":"Although look like easy optimization, numerous (failed) versions, version often required fiddling syntax make sure right results calculated. example, happens ph vector (matrix) put matrix operation? always might expect. optimizations described reduced user time 10.76 seconds 3.38 seconds. total effect optimizations algorithm reduced user time nipals function 19.20 seconds 3.38 seconds example.","code":""},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"calculating-pp-and-tt","dir":"Articles","previous_headings":"","what":"Calculating PP’ and TT’","title":"NIPALS optimization notes","text":"Gram-Schmidt orthogonalization part algorithm, necessary calculate PhPh′P_h P_h' PhP_h matrix first hh columns loadings matrix PP. necessary re-calculate entire PhPh′P_h P_h' product Principal Component, update product $\\bf P_h P_h' = P_{h-1} P_{h-1}' + p_h p_h'$. ’s numerical illustration: Using 100×100100 \\times 100 matrix example, Gram-Schmidt method adds modest increase time.","code":"set.seed(42) P = matrix(rnorm(9), 3) PPp = P %*% t(P) all.equal(PPp,           P[,1,drop=FALSE] %*% t(P[,1,drop=FALSE]) +           P[,2,drop=FALSE] %*% t(P[,2,drop=FALSE]) +           P[,3,drop=FALSE] %*% t(P[,3,drop=FALSE]) ) # TRUE  all.equal(PPp,           tcrossprod(P[,1]) + tcrossprod(P[,2]) + tcrossprod(P[,3]) ) # TRUE  # multiply by a  vector all.equal( PPp %*% 1:3,            tcrossprod(PPp, t(1:3)) ) # TRUE system.time(m1 <- nipals(Bbig2, ncomp=100, gramschmidt=FALSE)) #   user  system elapsed  #   3.68    0.02    3.70  system.time(m2 <- nipals(Bbig2, ncomp=100, gramschmidt=TRUE)) #   user  system elapsed  #   4.29    0.03    4.37"},{"path":"https://kwstat.github.io/nipals/articles/nipals_optimization.html","id":"r-vs-c-comment","dir":"Articles","previous_headings":"Calculating PP’ and TT’","what":"R vs C comment","title":"NIPALS optimization notes","text":"nipals() function makes heavy use crossprod() tcrossprod() functions, already extensively optimized. Non-optimized coding NIPALS algorithm C probably less efficient R version used package.","code":""},{"path":"https://kwstat.github.io/nipals/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Wright. Author, maintainer, copyright holder.","code":""},{"path":"https://kwstat.github.io/nipals/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wright K (2024). nipals: Principal Components Analysis using NIPALS Weighted EMPCA, Gram-Schmidt Orthogonalization. R package version 1.0, https://kwstat.github.io/nipals/.","code":"@Manual{,   title = {nipals: Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization},   author = {Kevin Wright},   year = {2024},   note = {R package version 1.0},   url = {https://kwstat.github.io/nipals/}, }"},{"path":"https://kwstat.github.io/nipals/index.html","id":"nipals-","dir":"","previous_headings":"","what":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","title":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","text":"Homepage: https://kwstat.github.io/nipals Repository: https://github.com/kwstat/nipals nipals package provides two functions perform Principal Components Analysis matrix: 1. nipals function uses Non-linear Iterative Partial Least Squares. 2. empca function uses EM PCA. NIPALS implemented several times R packages. EMPCA previously appeared python, available R first time. package strives best (fast accurate) R implementations. empca() function considered experimental. problem using empca() matrices (1) non-full rank (2) missing values.","code":""},{"path":"https://kwstat.github.io/nipals/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key features","title":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","text":"Missing values allowed. Uses Gram-Schmidt ensure orthogonal principal components. Carefully optimized speed (nipals , empca). Flexible options. Vignettes unit tests. Weights allowed (empca ).","code":""},{"path":"https://kwstat.github.io/nipals/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","text":"","code":"# Install the released version from CRAN: install.packages(\"nipals\")  # Install the development version from GitHub: install.packages(\"devtools\") devtools::install_github(\"kwstat/nipals\")"},{"path":"https://kwstat.github.io/nipals/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","text":"","code":"require(nipals) data(uscrime, package = \"nipals\") dat <- uscrime dat <- as.matrix(dat[ , -1])  # Gram-Schmidt corrected NIPALS m3 <- nipals(dat)  # Show that the Principal Components are orthogonal round(crossprod(m3$loadings),3) ##      PC1 PC2 PC3 PC4 PC5 PC6 PC7 ##  PC1   1   0   0   0   0   0   0 ##  PC2   0   1   0   0   0   0   0 ##  PC3   0   0   1   0   0   0   0 ##  PC4   0   0   0   1   0   0   0 ##  PC5   0   0   0   0   1   0   0 ##  PC6   0   0   0   0   0   1   0 ##  PC7   0   0   0   0   0   0   1  round(m3$loadings,3) ##              PC1    PC2    PC3    PC4    PC5    PC6    PC7 ##  murder    0.296 -0.623  0.178 -0.241  0.540 -0.265 -0.270 ##  rape      0.432 -0.171 -0.244  0.060  0.200  0.769  0.299 ##  robbery   0.397  0.044  0.496 -0.558 -0.519  0.120  0.005 ##  assault   0.399 -0.353 -0.063  0.629 -0.502 -0.166 -0.191 ##  burglary  0.440  0.204 -0.211 -0.057  0.095 -0.540  0.645 ##  larceny   0.358  0.401 -0.541 -0.231  0.023 -0.037 -0.602 ##  autotheft 0.295  0.504  0.567  0.418  0.372  0.054 -0.148  m4 <- empca(dat)  # Show that the Principal Components are orthogonal round(crossprod(m4$loadings),3) ##     PC1 PC2 PC3 PC4 PC5 PC6 PC7 ## PC1   1   0   0   0   0   0   0 ## PC2   0   1   0   0   0   0   0 ## PC3   0   0   1   0   0   0   0 ## PC4   0   0   0   1   0   0   0 ## PC5   0   0   0   0   1   0   0 ## PC6   0   0   0   0   0   1   0 ## PC7   0   0   0   0   0   0   1  round(m4$loadings,3) ##             PC1    PC2    PC3    PC4    PC5    PC6    PC7 ## murder    0.301 -0.642  0.168 -0.433  0.447  0.062  0.278 ## rape      0.431 -0.146 -0.266  0.106 -0.018 -0.799 -0.269 ## robbery   0.399  0.023  0.488 -0.306 -0.712  0.028 -0.012 ## assault   0.396 -0.336 -0.099  0.734 -0.161  0.349  0.181 ## burglary  0.441  0.197 -0.191 -0.179  0.229  0.459 -0.659 ## larceny   0.353  0.430 -0.515 -0.245 -0.044  0.050  0.601 ## autotheft 0.295  0.478  0.593  0.275  0.461 -0.150  0.150"},{"path":"https://kwstat.github.io/nipals/index.html","id":"see-also","dir":"","previous_headings":"","what":"See also","title":"Principal Components Analysis using NIPALS or Weighted EMPCA, with Gram-Schmidt Orthogonalization","text":"python version package can found https://pypi.org/project/nipals/.","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Average angular distance between two rotation matrices — avg_angular_distance","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"matrices B, calculate angle column vectors corresponding column vectors B. average angles.","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"","code":"avg_angular_distance(A, B)"},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"Matrix B Matrix","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"single floating point number, radians.","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"results singular value decomposition X=USV' unique, change sign columns U, indicates axis flipped.","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"None","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/nipals/reference/avg_angular_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average angular distance between two rotation matrices — avg_angular_distance","text":"","code":"# Example from https://math.stackexchange.com/questions/2113634/ rot1 <- matrix(c(-0.956395958, -0.292073218, 0.000084963,                  0.292073230, -0.956395931, 0.000227268,                  0.000014880, 0.000242173, 0.999999971),                ncol=3, byrow=TRUE) rot2 <- matrix(c(-0.956227882, -0.292623029, -0.000021887,                  0.292623030, -0.956227882, -0.000024473,                  -0.000013768, -0.000029806, 0.999999999),                ncol=3, byrow=TRUE) avg_angular_distance(rot1, rot2) # .0004950387 #> [1] 0.0004950387"},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"Used finding principal components numeric matrix. Missing values matrix allowed. Weights element matrix allowed. Principal Components extracted one time. algorithm computes x = TP', T 'scores' matrix P 'loadings' matrix.","code":""},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"","code":"empca(   x,   w,   ncomp = min(nrow(x), ncol(x)),   center = TRUE,   scale = TRUE,   maxiter = 100,   tol = 1e-06,   seed = NULL,   fitted = FALSE,   gramschmidt = TRUE,   verbose = FALSE )"},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"x Numerical matrix find principal components. Missing values allowed. w Numerical matrix weights. ncomp Maximum number principal components extract x. center TRUE, subtract mean column x PCA. scale TRUE, divide standard deviation column x PCA. maxiter Maximum number EM iterations principal component. tol Default 1e-6 tolerance testing convergence EM iterations principal component. seed Random seed use initializing random rotation matrix. fitted Default FALSE. TRUE, return fitted (reconstructed) value x. gramschmidt Default TRUE. TRUE, perform Gram-Schmidt orthogonalization iteration. verbose Default FALSE. Use TRUE 1 show diagnostics.","code":""},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"list components eig, scores, loadings, fitted, ncomp, R2, iter, center, scale.","code":""},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"Stephen Bailey (2012). Principal Component Analysis Noisy /Missing Data. Publications Astronomical Society Pacific. http://doi.org/10.1086/668105","code":""},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/nipals/reference/empca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal component analysis by weighted EMPCA, expectation maximization principal component-analysis — empca","text":"","code":"B <- matrix(c(50, 67, 90, 98, 120,               55, 71, 93, 102, 129,               65, 76, 95, 105, 134,               50, 80, 102, 130, 138,               60, 82, 97, 135, 151,               65, 89, 106, 137, 153,               75, 95, 117, 133, 155), ncol=5, byrow=TRUE) rownames(B) <- c(\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\",\"G7\") colnames(B) <- c(\"E1\",\"E2\",\"E3\",\"E4\",\"E5\") dim(B) # 7 x 5 #> [1] 7 5 p1 <- empca(B) dim(p1$scores) # 7 x 5 #> [1] 7 5 dim(p1$loadings) # 5 x 5 #> [1] 5 5  B2 = B B2[1,1] = B2[2,2] = NA p2 = empca(B2, fitted=TRUE)"},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"Used finding principal components numeric matrix x. Missing values matrix allowed. Principal Components extracted one time. algorithm computes x = TLP', T scores matrix, L (Lambda) eigenvalue vector, P loadings matrix.","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"","code":"nipals(   x,   ncomp = min(nrow(x), ncol(x)),   center = TRUE,   scale = TRUE,   maxiter = 500,   tol = 1e-06,   startcol = 0,   fitted = FALSE,   force.na = FALSE,   gramschmidt = TRUE,   verbose = FALSE )"},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"x Numerical matrix find principal compontents. Missing values allowed. ncomp Maximum number principal components extract x. center TRUE, subtract mean column x PCA. scale TRUE, divide standard deviation column x PCA. maxiter Maximum number NIPALS iterations principal component. tol Default 1e-6 tolerance testing convergence NIPALS iterations principal component. startcol Determine starting column x iterations principal component. 0, use column x maximum absolute sum. number, use column x. function, apply function column x choose column maximum value function. fitted Default FALSE. TRUE, return fitted (reconstructed) value x. force.na Default FALSE. TRUE, force function use method missing values, even missing values x. gramschmidt Default TRUE. TRUE, perform Gram-Schmidt orthogonalization iteration. verbose Default FALSE. Use TRUE 1 show diagnostics.","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"list components eig, scores, loadings, fitted, ncomp, R2, iter, center, scale.","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"CAUTION: Different R package functions different things L matrix. example, functions include L T. R2 values reported marginal, cumulative.","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"Wold, H. (1966) Estimation principal components related models iterative least squares. Multivariate Analysis (Ed., P.R. Krishnaiah), Academic Press, NY, 391-420. Andrecut, Mircea (2009). Parallel GPU implementation iterative PCA algorithms. Journal Computational Biology, 16, 1593-1599.","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"Kevin Wright","code":""},{"path":"https://kwstat.github.io/nipals/reference/nipals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal component analysis by NIPALS, non-linear iterative partial least squares — nipals","text":"","code":"B <- matrix(c(50, 67, 90, 98, 120,               55, 71, 93, 102, 129,               65, 76, 95, 105, 134,               50, 80, 102, 130, 138,               60, 82, 97, 135, 151,               65, 89, 106, 137, 153,               75, 95, 117, 133, 155), ncol=5, byrow=TRUE) rownames(B) <- c(\"G1\",\"G2\",\"G3\",\"G4\",\"G5\",\"G6\",\"G7\") colnames(B) <- c(\"E1\",\"E2\",\"E3\",\"E4\",\"E5\") dim(B) # 7 x 5 #> [1] 7 5 p1 <- nipals(B) dim(p1$scores) # 7 x 5 #> [1] 7 5 dim(p1$loadings) # 5 x 5 #> [1] 5 5  B2 = B B2[1,1] = B2[2,2] = NA p2 = nipals(B2, fitted=TRUE)  # Two ways to make a biplot  # method 1 biplot(p2$scores, p2$loadings)   # method 2 class(p2) <- \"princomp\" p2$sdev <- sqrt(p2$eig) biplot(p2, scale=0)"},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":null,"dir":"Reference","previous_headings":"","what":"U.S. Crime rates per 100,00 people — uscrime","title":"U.S. Crime rates per 100,00 people — uscrime","text":"U.S. Crime rates per 100,00 people 7 categories 50 U.S. states 1977.","code":""},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"U.S. Crime rates per 100,00 people — uscrime","text":"","code":"uscrime"},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"U.S. Crime rates per 100,00 people — uscrime","text":"data frame 50 observations following 8 variables. state U.S. state murder murders rape rapes robbery robbery assault assault burglary burglary larceny larceny autotheft automobile thefts","code":""},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"U.S. Crime rates per 100,00 people — uscrime","text":"Documentation Example 3 PROC HPPRINCOMP. http://documentation.sas.com/api/docsets/stathpug/14.2/content/stathpug_code_hppriex3.htm?locale=en","code":""},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"U.S. Crime rates per 100,00 people — uscrime","text":"two missing values.","code":""},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"U.S. Crime rates per 100,00 people — uscrime","text":"SAS/STAT User's Guide: High-Performance Procedures.  HPPRINCOMP Procedure. http://support.sas.com/documentation/cdl/en/stathpug/67524/HTML/default/viewer.htm#stathpug_hpprincomp_toc.htm","code":""},{"path":"https://kwstat.github.io/nipals/reference/uscrime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"U.S. Crime rates per 100,00 people — uscrime","text":"","code":"library(nipals) head(uscrime) #>        state murder rape robbery assault burglary larceny autotheft #> 1    Alabama   14.2 25.2    96.8   278.3   1135.5  1881.9     280.7 #> 2     Alaska   10.8 51.6    96.8   284.0   1331.7  3369.8     753.3 #> 3    Arizona    9.5 34.2   138.2   312.3   2346.1  4467.4     439.5 #> 4   Arkansas    8.8 27.6    83.2   203.4    972.6  1862.1     183.4 #> 5 California   11.5 49.4   287.0   358.0   2139.4  3499.8     663.5 #> 6   Colorado    6.3 42.0   170.7   292.9   1935.2  3903.2     477.1  # SAS deletes rows with missing values dat <- uscrime[complete.cases(uscrime), ] dat <- as.matrix(dat[ , -1]) m1 <- nipals(dat) # complete-data method  # Traditional NIPALS with missing data   dat <- uscrime dat <- as.matrix(dat[ , -1]) m2 <- nipals(dat, gramschmidt=FALSE) # missing  round(crossprod(m2$loadings),3) # Prin Comps not quite orthogonal #>        PC1    PC2    PC3    PC4    PC5    PC6    PC7 #> PC1  1.000  0.002  0.002 -0.001 -0.001 -0.002  0.005 #> PC2  0.002  1.000  0.001 -0.001  0.000 -0.006  0.004 #> PC3  0.002  0.001  1.000  0.000  0.000 -0.001  0.000 #> PC4 -0.001 -0.001  0.000  1.000  0.000  0.001  0.002 #> PC5 -0.001  0.000  0.000  0.000  1.000 -0.002 -0.002 #> PC6 -0.002 -0.006 -0.001  0.001 -0.002  1.000  0.005 #> PC7  0.005  0.004  0.000  0.002 -0.002  0.005  1.000    # Gram-Schmidt corrected NIPALS m3 <- nipals(dat, gramschmidt=TRUE) # TRUE is default round(crossprod(m3$loadings),3) # Prin Comps are orthogonal #>     PC1 PC2 PC3 PC4 PC5 PC6 PC7 #> PC1   1   0   0   0   0   0   0 #> PC2   0   1   0   0   0   0   0 #> PC3   0   0   1   0   0   0   0 #> PC4   0   0   0   1   0   0   0 #> PC5   0   0   0   0   1   0   0 #> PC6   0   0   0   0   0   1   0 #> PC7   0   0   0   0   0   0   1"},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-10-2024-12-02","dir":"Changelog","previous_headings":"","what":"nipals 1.0 (2024-12-02)","title":"nipals 1.0 (2024-12-02)","text":"Add avg_angular_distance() function. Add tests. Switch MIT license. Documentation pages now created via Github Actions. Clarify nipals() returns T*Lambda*P'.","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-08-2021-08-01","dir":"Changelog","previous_headings":"","what":"nipals 0.8 (2021-08-01)","title":"nipals 0.8 (2021-08-01)","text":"CRAN release: 2021-09-15 Fix issue (#5). floating-point error created dot product outside [-1,1].","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-07-2020-01-24","dir":"Changelog","previous_headings":"","what":"nipals 0.7 (2020-01-24)","title":"nipals 0.7 (2020-01-24)","text":"CRAN release: 2020-01-24 Fix ‘additional issues’ reported CRAN (#3).","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-06-2020-01-01","dir":"Changelog","previous_headings":"","what":"nipals 0.6 (2020-01-01)","title":"nipals 0.6 (2020-01-01)","text":"Calculating xhat ncomp=1 now works (#2). nipals() now returns center scale fitted model object, makes easier get predictions model (#1). New (experimental) function empca() calculate principal components via weighted EM PCA. Row/column names added fitted matrix.","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-05-2018-10-24","dir":"Changelog","previous_headings":"","what":"nipals 0.5 (2018-10-24)","title":"nipals 0.5 (2018-10-24)","text":"CRAN release: 2018-10-24 Row/column names added fitted matrix. New startcol argument can now function applied every column. slight change automatic start column selection. default, start column column largest sum absolute values. (Formerly, start column column largest variance, make sense columns scaled.)","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-04-2018-02-11","dir":"Changelog","previous_headings":"","what":"nipals 0.4 (2018-02-11)","title":"nipals 0.4 (2018-02-11)","text":"CRAN release: 2018-02-11","code":""},{"path":"https://kwstat.github.io/nipals/news/index.html","id":"nipals-03-2017-11-14","dir":"Changelog","previous_headings":"","what":"nipals 0.3 (2017-11-14)","title":"nipals 0.3 (2017-11-14)","text":"CRAN release: 2017-11-14 nipals() function split gge package, extensively optimized compared implementations packages. First release CRAN.","code":""}]
